### 1- Sobre o primeiro trecho do livro "Software Engineering at Google, Oreilly":
O texto explica que, apesar de muita gente usar “programação” e “engenharia de software” como se fossem a mesma coisa, elas não são exatamente iguais. Programação é mais associada a escrever código, enquanto engenharia de software passa a ideia de usar conhecimento teórico de forma mais séria e estruturada para criar algo real. Assim como outros engenheiros constroem coisas físicas usando teoria e regras bem definidas, o engenheiro de software também cria algo real, mesmo que seja intangível.

A diferença é que outras engenharias seguem métodos muito rigorosos, porque erros podem causar grandes danos, enquanto o desenvolvimento de software nem sempre teve esse mesmo nível de rigor. Porém, como o software está cada vez mais presente em tudo, está se tornando necessário adotar práticas mais organizadas e confiáveis, como uma verdadeira engenharia, para garantir qualidade e segurança.

---

### 2- Sobre o segundo trecho do livro "Software Engineering at Google, Oreilly":
O texto diz que engenharia de software envolve não só programar, mas também todos os processos e 
ferramentas usados para manter o código ao longo do tempo. A ideia principal é que engenharia de software é como “programação ao longo do tempo”, ou seja, criar código que seja sustentável e fácil de modificar durante sua vida útil. Também destaca que é importante pensar em três pontos: o código vai mudar com o tempo, o sistema e a empresa podem crescer, e é preciso tomar decisões equilibrando custos e benefícios.

---
### 3- Requisitos não funcionais:

**1. Performance**

Se trata do quão bem o sistema performa, ou seja, o quão rápido e eficiente ele é nos processos executados durante o uso. Por exemplo tempo para carregar páginas, tempo para responder à algum comando dado.

**2. Extensibility (Extensibilidade)**

Se trata do quão fácil é para um sistema ser ampliado e modificado ou seja, quanto mais simples para os desenvolvedores adicionarem novas funcionalidades, maior a extensibilidade do mesmo.

**3. Deployability (Implantabilidade)**

Se trata do quão eficiente é para o sistema ser implantado. 

**4. Security (Segurança)**

Se trata do quão seguro um sistem é para o usuário, se ele pode confiar em informar seus dados pessoais. Usando o mesmo exemplo dos slides, o sistema de um banco tem que ser seguro o suficiente para guardar os dados dos clientes, seguro contra ataques de hackers, invasões ou roubo de informações

**5. Usability (Usablilidade)**

Se trata da fácilidade de uso do sistema para o usuário. Um sistema que se preocupa bastante com a experiência do usuário, é um sistema com uma boa usabilidade.

---

### 4- Exemplos de tradeoffs:

**1. Rapidez vs. Código bem feito**

Às vezes eu posso fazer um código rápido só pra funcionar, sem organizar muito. Isso resolve o problema na hora, mas depois fica difícil de entender e modificar. Se eu organizo melhor, demora mais, mas facilita no futuro.

**2. Simplicidade vs. Preparação para o futuro**

Posso fazer algo simples que resolve só o que preciso agora, mas que não serve para outras situações. Ou posso fazer algo mais genérico, que demora mais, mas que posso reutilizar depois sem precisar refazer tudo.

**3. Performance vs. Facilidade de desenvolvimento**

Posso usar uma solução mais simples, que é mais fácil de programar, mas que não é tão rápida. Ou posso usar uma solução mais otimizada, que é mais rápida, mas mais difícil de implementar e entender.
