### 1- Sobre o primeiro trecho do livro "Software Engineering at Google, Oreilly":
O texto explica que, apesar de muita gente usar “programação” e “engenharia de software” como se fossem a mesma coisa, elas não são exatamente iguais. Programação é mais associada a escrever código, enquanto engenharia de software passa a ideia de usar conhecimento teórico de forma mais séria e estruturada para criar algo real. Assim como outros engenheiros constroem coisas físicas usando teoria e regras bem definidas, o engenheiro de software também cria algo real, mesmo que seja intangível.

A diferença é que outras engenharias seguem métodos muito rigorosos, porque erros podem causar grandes danos, enquanto o desenvolvimento de software nem sempre teve esse mesmo nível de rigor. Porém, como o software está cada vez mais presente em tudo, está se tornando necessário adotar práticas mais organizadas e confiáveis, como uma verdadeira engenharia, para garantir qualidade e segurança.

---

### 2- Sobre o segundo trecho do livro "Software Engineering at Google, Oreilly":
O texto diz que engenharia de software envolve não só programar, mas também todos os processos e 
ferramentas usados para manter o código ao longo do tempo. A ideia principal é que engenharia de software é como “programação ao longo do tempo”, ou seja, criar código que seja sustentável e fácil de modificar durante sua vida útil. Também destaca que é importante pensar em três pontos: o código vai mudar com o tempo, o sistema e a empresa podem crescer, e é preciso tomar decisões equilibrando custos e benefícios.

---

### 3- Exemplos de tradeoffs:

**1. Rapidez vs. Código bem feito**

Às vezes eu posso fazer um código rápido só pra funcionar, sem organizar muito. Isso resolve o problema na hora, mas depois fica difícil de entender e modificar. Se eu organizo melhor, demora mais, mas facilita no futuro.

**2. Simplicidade vs. Preparação para o futuro**

Posso fazer algo simples que resolve só o que preciso agora, mas que não serve para outras situações. Ou posso fazer algo mais genérico, que demora mais, mas que posso reutilizar depois sem precisar refazer tudo.

**3. Performance vs. Facilidade de desenvolvimento**

Posso usar uma solução mais simples, que é mais fácil de programar, mas que não é tão rápida. Ou posso usar uma solução mais otimizada, que é mais rápida, mas mais difícil de implementar e entender.
